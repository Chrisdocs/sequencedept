{"ast":null,"code":"import fs from 'node:fs';\nimport arrayUnion from 'array-union';\nimport merge2 from 'merge2';\nimport fastGlob from 'fast-glob';\nimport dirGlob from 'dir-glob';\nimport { isGitIgnored, isGitIgnoredSync } from './gitignore.js';\nimport { FilterStream, UniqueStream } from './stream-utils.js';\n\nconst DEFAULT_FILTER = () => false;\n\nconst isNegative = pattern => pattern[0] === '!';\n\nconst assertPatternsInput = patterns => {\n  if (!patterns.every(pattern => typeof pattern === 'string')) {\n    throw new TypeError('Patterns must be a string or an array of strings');\n  }\n};\n\nconst checkCwdOption = (options = {}) => {\n  if (!options.cwd) {\n    return;\n  }\n\n  let stat;\n\n  try {\n    stat = fs.statSync(options.cwd);\n  } catch {\n    return;\n  }\n\n  if (!stat.isDirectory()) {\n    throw new Error('The `cwd` option must be a path to a directory');\n  }\n};\n\nconst getPathString = p => p.stats instanceof fs.Stats ? p.path : p;\n\nexport const generateGlobTasks = (patterns, taskOptions) => {\n  patterns = arrayUnion([patterns].flat());\n  assertPatternsInput(patterns);\n  checkCwdOption(taskOptions);\n  const globTasks = [];\n  taskOptions = {\n    ignore: [],\n    expandDirectories: true,\n    ...taskOptions\n  };\n\n  for (const [index, pattern] of patterns.entries()) {\n    if (isNegative(pattern)) {\n      continue;\n    }\n\n    const ignore = patterns.slice(index).filter(pattern => isNegative(pattern)).map(pattern => pattern.slice(1));\n    const options = { ...taskOptions,\n      ignore: [...taskOptions.ignore, ...ignore]\n    };\n    globTasks.push({\n      pattern,\n      options\n    });\n  }\n\n  return globTasks;\n};\n\nconst globDirectories = (task, fn) => {\n  let options = {};\n\n  if (task.options.cwd) {\n    options.cwd = task.options.cwd;\n  }\n\n  if (Array.isArray(task.options.expandDirectories)) {\n    options = { ...options,\n      files: task.options.expandDirectories\n    };\n  } else if (typeof task.options.expandDirectories === 'object') {\n    options = { ...options,\n      ...task.options.expandDirectories\n    };\n  }\n\n  return fn(task.pattern, options);\n};\n\nconst getPattern = (task, fn) => task.options.expandDirectories ? globDirectories(task, fn) : [task.pattern];\n\nconst getFilterSync = options => options && options.gitignore ? isGitIgnoredSync({\n  cwd: options.cwd,\n  ignore: options.ignore\n}) : DEFAULT_FILTER;\n\nconst globToTask = task => async glob => {\n  const {\n    options\n  } = task;\n\n  if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n    options.ignore = await dirGlob(options.ignore);\n  }\n\n  return {\n    pattern: glob,\n    options\n  };\n};\n\nconst globToTaskSync = task => glob => {\n  const {\n    options\n  } = task;\n\n  if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n    options.ignore = dirGlob.sync(options.ignore);\n  }\n\n  return {\n    pattern: glob,\n    options\n  };\n};\n\nexport const globby = async (patterns, options) => {\n  const globTasks = generateGlobTasks(patterns, options);\n\n  const getFilter = async () => options && options.gitignore ? isGitIgnored({\n    cwd: options.cwd,\n    ignore: options.ignore\n  }) : DEFAULT_FILTER;\n\n  const getTasks = async () => {\n    const tasks = await Promise.all(globTasks.map(async task => {\n      const globs = await getPattern(task, dirGlob);\n      return Promise.all(globs.map(globToTask(task)));\n    }));\n    return arrayUnion(...tasks);\n  };\n\n  const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);\n  const paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));\n  return arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));\n};\nexport const globbySync = (patterns, options) => {\n  const globTasks = generateGlobTasks(patterns, options);\n  const tasks = [];\n\n  for (const task of globTasks) {\n    const newTask = getPattern(task, dirGlob.sync).map(globToTaskSync(task));\n    tasks.push(...newTask);\n  }\n\n  const filter = getFilterSync(options);\n  let matches = [];\n\n  for (const task of tasks) {\n    matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));\n  }\n\n  return matches.filter(path_ => !filter(path_));\n};\nexport const globbyStream = (patterns, options) => {\n  const globTasks = generateGlobTasks(patterns, options);\n  const tasks = [];\n\n  for (const task of globTasks) {\n    const newTask = getPattern(task, dirGlob.sync).map(globToTaskSync(task));\n    tasks.push(...newTask);\n  }\n\n  const filter = getFilterSync(options);\n  const filterStream = new FilterStream(p => !filter(p));\n  const uniqueStream = new UniqueStream();\n  return merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);\n};\nexport const isDynamicPattern = (patterns, options) => [patterns].flat().some(pattern => fastGlob.isDynamicPattern(pattern, options));\nexport { isGitIgnored, isGitIgnoredSync } from './gitignore.js';","map":{"version":3,"sources":["/Users/chriswolfe/Documents/webDev/Clients/SQ-DPT/my-app/node_modules/imagemin/node_modules/globby/index.js"],"names":["fs","arrayUnion","merge2","fastGlob","dirGlob","isGitIgnored","isGitIgnoredSync","FilterStream","UniqueStream","DEFAULT_FILTER","isNegative","pattern","assertPatternsInput","patterns","every","TypeError","checkCwdOption","options","cwd","stat","statSync","isDirectory","Error","getPathString","p","stats","Stats","path","generateGlobTasks","taskOptions","flat","globTasks","ignore","expandDirectories","index","entries","slice","filter","map","push","globDirectories","task","fn","Array","isArray","files","getPattern","getFilterSync","gitignore","globToTask","glob","globToTaskSync","sync","globby","getFilter","getTasks","tasks","Promise","all","globs","paths","path_","globbySync","newTask","matches","globbyStream","filterStream","uniqueStream","stream","pipe","isDynamicPattern","some"],"mappings":"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","sourcesContent":["import fs from 'node:fs';\nimport arrayUnion from 'array-union';\nimport merge2 from 'merge2';\nimport fastGlob from 'fast-glob';\nimport dirGlob from 'dir-glob';\nimport {isGitIgnored, isGitIgnoredSync} from './gitignore.js';\nimport {FilterStream, UniqueStream} from './stream-utils.js';\n\nconst DEFAULT_FILTER = () => false;\n\nconst isNegative = pattern => pattern[0] === '!';\n\nconst assertPatternsInput = patterns => {\n\tif (!patterns.every(pattern => typeof pattern === 'string')) {\n\t\tthrow new TypeError('Patterns must be a string or an array of strings');\n\t}\n};\n\nconst checkCwdOption = (options = {}) => {\n\tif (!options.cwd) {\n\t\treturn;\n\t}\n\n\tlet stat;\n\ttry {\n\t\tstat = fs.statSync(options.cwd);\n\t} catch {\n\t\treturn;\n\t}\n\n\tif (!stat.isDirectory()) {\n\t\tthrow new Error('The `cwd` option must be a path to a directory');\n\t}\n};\n\nconst getPathString = p => p.stats instanceof fs.Stats ? p.path : p;\n\nexport const generateGlobTasks = (patterns, taskOptions) => {\n\tpatterns = arrayUnion([patterns].flat());\n\tassertPatternsInput(patterns);\n\tcheckCwdOption(taskOptions);\n\n\tconst globTasks = [];\n\n\ttaskOptions = {\n\t\tignore: [],\n\t\texpandDirectories: true,\n\t\t...taskOptions,\n\t};\n\n\tfor (const [index, pattern] of patterns.entries()) {\n\t\tif (isNegative(pattern)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ignore = patterns\n\t\t\t.slice(index)\n\t\t\t.filter(pattern => isNegative(pattern))\n\t\t\t.map(pattern => pattern.slice(1));\n\n\t\tconst options = {\n\t\t\t...taskOptions,\n\t\t\tignore: [...taskOptions.ignore, ...ignore],\n\t\t};\n\n\t\tglobTasks.push({pattern, options});\n\t}\n\n\treturn globTasks;\n};\n\nconst globDirectories = (task, fn) => {\n\tlet options = {};\n\tif (task.options.cwd) {\n\t\toptions.cwd = task.options.cwd;\n\t}\n\n\tif (Array.isArray(task.options.expandDirectories)) {\n\t\toptions = {\n\t\t\t...options,\n\t\t\tfiles: task.options.expandDirectories,\n\t\t};\n\t} else if (typeof task.options.expandDirectories === 'object') {\n\t\toptions = {\n\t\t\t...options,\n\t\t\t...task.options.expandDirectories,\n\t\t};\n\t}\n\n\treturn fn(task.pattern, options);\n};\n\nconst getPattern = (task, fn) => task.options.expandDirectories ? globDirectories(task, fn) : [task.pattern];\n\nconst getFilterSync = options => options && options.gitignore\n\t? isGitIgnoredSync({cwd: options.cwd, ignore: options.ignore})\n\t: DEFAULT_FILTER;\n\nconst globToTask = task => async glob => {\n\tconst {options} = task;\n\tif (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n\t\toptions.ignore = await dirGlob(options.ignore);\n\t}\n\n\treturn {\n\t\tpattern: glob,\n\t\toptions,\n\t};\n};\n\nconst globToTaskSync = task => glob => {\n\tconst {options} = task;\n\tif (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n\t\toptions.ignore = dirGlob.sync(options.ignore);\n\t}\n\n\treturn {\n\t\tpattern: glob,\n\t\toptions,\n\t};\n};\n\nexport const globby = async (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst getFilter = async () => options && options.gitignore\n\t\t? isGitIgnored({cwd: options.cwd, ignore: options.ignore})\n\t\t: DEFAULT_FILTER;\n\n\tconst getTasks = async () => {\n\t\tconst tasks = await Promise.all(globTasks.map(async task => {\n\t\t\tconst globs = await getPattern(task, dirGlob);\n\t\t\treturn Promise.all(globs.map(globToTask(task)));\n\t\t}));\n\n\t\treturn arrayUnion(...tasks);\n\t};\n\n\tconst [filter, tasks] = await Promise.all([getFilter(), getTasks()]);\n\tconst paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));\n\n\treturn arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));\n};\n\nexport const globbySync = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = [];\n\tfor (const task of globTasks) {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTaskSync(task));\n\t\ttasks.push(...newTask);\n\t}\n\n\tconst filter = getFilterSync(options);\n\n\tlet matches = [];\n\tfor (const task of tasks) {\n\t\tmatches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));\n\t}\n\n\treturn matches.filter(path_ => !filter(path_));\n};\n\nexport const globbyStream = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = [];\n\tfor (const task of globTasks) {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTaskSync(task));\n\t\ttasks.push(...newTask);\n\t}\n\n\tconst filter = getFilterSync(options);\n\tconst filterStream = new FilterStream(p => !filter(p));\n\tconst uniqueStream = new UniqueStream();\n\n\treturn merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options)))\n\t\t.pipe(filterStream)\n\t\t.pipe(uniqueStream);\n};\n\nexport const isDynamicPattern = (patterns, options) => [patterns].flat()\n\t.some(pattern => fastGlob.isDynamicPattern(pattern, options));\n\nexport {\n\tisGitIgnored,\n\tisGitIgnoredSync,\n} from './gitignore.js';\n"]},"metadata":{},"sourceType":"module"}