{"ast":null,"code":"import { Buffer } from 'node:buffer';\nimport { promises as fsPromises } from 'node:fs';\nimport { promisify } from 'node:util';\nimport path from 'node:path';\nimport fs from 'graceful-fs';\nimport FileType from 'file-type';\nimport { globby } from 'globby';\nimport pPipe from 'p-pipe';\nimport replaceExt from 'replace-ext';\nimport junk from 'junk';\nimport convertToUnixPath from 'slash';\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\n\nconst handleFile = async (sourcePath, {\n  destination,\n  plugins = []\n}) => {\n  if (plugins && !Array.isArray(plugins)) {\n    throw new TypeError('The `plugins` option should be an `Array`');\n  }\n\n  let data = await readFile(sourcePath);\n  data = await (plugins.length > 0 ? pPipe(...plugins)(data) : data);\n  const {\n    ext\n  } = (await FileType.fromBuffer(data)) || {\n    ext: path.extname(sourcePath)\n  };\n  let destinationPath = destination ? path.join(destination, path.basename(sourcePath)) : undefined;\n  destinationPath = ext === 'webp' ? replaceExt(destinationPath, '.webp') : destinationPath;\n  const returnValue = {\n    data,\n    sourcePath,\n    destinationPath\n  };\n\n  if (!destinationPath) {\n    return returnValue;\n  }\n\n  await fsPromises.mkdir(path.dirname(returnValue.destinationPath), {\n    recursive: true\n  });\n  await writeFile(returnValue.destinationPath, returnValue.data);\n  return returnValue;\n};\n\nexport default async function imagemin(input, {\n  glob = true,\n  ...options\n} = {}) {\n  if (!Array.isArray(input)) {\n    throw new TypeError(`Expected an \\`Array\\`, got \\`${typeof input}\\``);\n  }\n\n  const unixFilePaths = input.map(path => convertToUnixPath(path));\n  const filePaths = glob ? await globby(unixFilePaths, {\n    onlyFiles: true\n  }) : input;\n  return Promise.all(filePaths.filter(filePath => junk.not(path.basename(filePath))).map(async filePath => {\n    try {\n      return await handleFile(filePath, options);\n    } catch (error) {\n      error.message = `Error occurred when handling file: ${input}\\n\\n${error.stack}`;\n      throw error;\n    }\n  }));\n}\n\nimagemin.buffer = async (input, {\n  plugins = []\n} = {}) => {\n  if (!Buffer.isBuffer(input)) {\n    throw new TypeError(`Expected a \\`Buffer\\`, got \\`${typeof input}\\``);\n  }\n\n  if (plugins.length === 0) {\n    return input;\n  }\n\n  return pPipe(...plugins)(input);\n};","map":{"version":3,"sources":["/Users/chriswolfe/Documents/webDev/Clients/SQ-DPT/my-app/node_modules/imagemin/index.js"],"names":["Buffer","promises","fsPromises","promisify","path","fs","FileType","globby","pPipe","replaceExt","junk","convertToUnixPath","readFile","writeFile","handleFile","sourcePath","destination","plugins","Array","isArray","TypeError","data","length","ext","fromBuffer","extname","destinationPath","join","basename","undefined","returnValue","mkdir","dirname","recursive","imagemin","input","glob","options","unixFilePaths","map","filePaths","onlyFiles","Promise","all","filter","filePath","not","error","message","stack","buffer","isBuffer"],"mappings":"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","sourcesContent":["import {Buffer} from 'node:buffer';\nimport {promises as fsPromises} from 'node:fs';\nimport {promisify} from 'node:util';\nimport path from 'node:path';\nimport fs from 'graceful-fs';\nimport FileType from 'file-type';\nimport {globby} from 'globby';\nimport pPipe from 'p-pipe';\nimport replaceExt from 'replace-ext';\nimport junk from 'junk';\nimport convertToUnixPath from 'slash';\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\n\nconst handleFile = async (sourcePath, {destination, plugins = []}) => {\n\tif (plugins && !Array.isArray(plugins)) {\n\t\tthrow new TypeError('The `plugins` option should be an `Array`');\n\t}\n\n\tlet data = await readFile(sourcePath);\n\tdata = await (plugins.length > 0 ? pPipe(...plugins)(data) : data);\n\n\tconst {ext} = await FileType.fromBuffer(data) || {ext: path.extname(sourcePath)};\n\tlet destinationPath = destination ? path.join(destination, path.basename(sourcePath)) : undefined;\n\tdestinationPath = ext === 'webp' ? replaceExt(destinationPath, '.webp') : destinationPath;\n\n\tconst returnValue = {\n\t\tdata,\n\t\tsourcePath,\n\t\tdestinationPath,\n\t};\n\n\tif (!destinationPath) {\n\t\treturn returnValue;\n\t}\n\n\tawait fsPromises.mkdir(path.dirname(returnValue.destinationPath), {recursive: true});\n\tawait writeFile(returnValue.destinationPath, returnValue.data);\n\n\treturn returnValue;\n};\n\nexport default async function imagemin(input, {glob = true, ...options} = {}) {\n\tif (!Array.isArray(input)) {\n\t\tthrow new TypeError(`Expected an \\`Array\\`, got \\`${typeof input}\\``);\n\t}\n\n\tconst unixFilePaths = input.map(path => convertToUnixPath(path));\n\tconst filePaths = glob ? await globby(unixFilePaths, {onlyFiles: true}) : input;\n\n\treturn Promise.all(\n\t\tfilePaths\n\t\t\t.filter(filePath => junk.not(path.basename(filePath)))\n\t\t\t.map(async filePath => {\n\t\t\t\ttry {\n\t\t\t\t\treturn await handleFile(filePath, options);\n\t\t\t\t} catch (error) {\n\t\t\t\t\terror.message = `Error occurred when handling file: ${input}\\n\\n${error.stack}`;\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}),\n\t);\n}\n\nimagemin.buffer = async (input, {plugins = []} = {}) => {\n\tif (!Buffer.isBuffer(input)) {\n\t\tthrow new TypeError(`Expected a \\`Buffer\\`, got \\`${typeof input}\\``);\n\t}\n\n\tif (plugins.length === 0) {\n\t\treturn input;\n\t}\n\n\treturn pPipe(...plugins)(input);\n};\n"]},"metadata":{},"sourceType":"module"}