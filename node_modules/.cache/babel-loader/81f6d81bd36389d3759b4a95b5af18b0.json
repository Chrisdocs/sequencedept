{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst execa = require('execa');\n\nconst pFinally = require('p-finally');\n\nconst pify = require('pify');\n\nconst rimraf = require('rimraf');\n\nconst tempfile = require('tempfile');\n\nconst fsP = pify(fs);\nconst rmP = pify(rimraf);\nconst input = Symbol('inputPath');\nconst output = Symbol('outputPath');\n\nmodule.exports = opts => {\n  opts = Object.assign({}, opts);\n\n  if (!Buffer.isBuffer(opts.input)) {\n    return Promise.reject(new Error('Input is required'));\n  }\n\n  if (typeof opts.bin !== 'string') {\n    return Promise.reject(new Error('Binary is required'));\n  }\n\n  if (!Array.isArray(opts.args)) {\n    return Promise.reject(new Error('Arguments are required'));\n  }\n\n  const inputPath = opts.inputPath || tempfile();\n  const outputPath = opts.outputPath || tempfile();\n  opts.args = opts.args.map(x => x === input ? inputPath : x === output ? outputPath : x);\n  const promise = fsP.writeFile(inputPath, opts.input).then(() => execa(opts.bin, opts.args)).then(() => fsP.readFile(outputPath));\n  return pFinally(promise, () => Promise.all([rmP(inputPath), rmP(outputPath)]));\n};\n\nmodule.exports.input = input;\nmodule.exports.output = output;","map":{"version":3,"sources":["/Users/chriswolfe/Documents/webDev/Clients/SQ-DPT/my-app/node_modules/exec-buffer/index.js"],"names":["fs","require","execa","pFinally","pify","rimraf","tempfile","fsP","rmP","input","Symbol","output","module","exports","opts","Object","assign","Buffer","isBuffer","Promise","reject","Error","bin","Array","isArray","args","inputPath","outputPath","map","x","promise","writeFile","then","readFile","all"],"mappings":"AAAA;;AACA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,UAAD,CAAxB;;AAEA,MAAMM,GAAG,GAAGH,IAAI,CAACJ,EAAD,CAAhB;AACA,MAAMQ,GAAG,GAAGJ,IAAI,CAACC,MAAD,CAAhB;AACA,MAAMI,KAAK,GAAGC,MAAM,CAAC,WAAD,CAApB;AACA,MAAMC,MAAM,GAAGD,MAAM,CAAC,YAAD,CAArB;;AAEAE,MAAM,CAACC,OAAP,GAAiBC,IAAI,IAAI;AACxBA,EAAAA,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,IAAlB,CAAP;;AAEA,MAAI,CAACG,MAAM,CAACC,QAAP,CAAgBJ,IAAI,CAACL,KAArB,CAAL,EAAkC;AACjC,WAAOU,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAU,mBAAV,CAAf,CAAP;AACA;;AAED,MAAI,OAAOP,IAAI,CAACQ,GAAZ,KAAoB,QAAxB,EAAkC;AACjC,WAAOH,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAU,oBAAV,CAAf,CAAP;AACA;;AAED,MAAI,CAACE,KAAK,CAACC,OAAN,CAAcV,IAAI,CAACW,IAAnB,CAAL,EAA+B;AAC9B,WAAON,OAAO,CAACC,MAAR,CAAe,IAAIC,KAAJ,CAAU,wBAAV,CAAf,CAAP;AACA;;AAED,QAAMK,SAAS,GAAGZ,IAAI,CAACY,SAAL,IAAkBpB,QAAQ,EAA5C;AACA,QAAMqB,UAAU,GAAGb,IAAI,CAACa,UAAL,IAAmBrB,QAAQ,EAA9C;AAEAQ,EAAAA,IAAI,CAACW,IAAL,GAAYX,IAAI,CAACW,IAAL,CAAUG,GAAV,CAAcC,CAAC,IAAIA,CAAC,KAAKpB,KAAN,GAAciB,SAAd,GAA0BG,CAAC,KAAKlB,MAAN,GAAegB,UAAf,GAA4BE,CAAzE,CAAZ;AAEA,QAAMC,OAAO,GAAGvB,GAAG,CAACwB,SAAJ,CAAcL,SAAd,EAAyBZ,IAAI,CAACL,KAA9B,EACduB,IADc,CACT,MAAM9B,KAAK,CAACY,IAAI,CAACQ,GAAN,EAAWR,IAAI,CAACW,IAAhB,CADF,EAEdO,IAFc,CAET,MAAMzB,GAAG,CAAC0B,QAAJ,CAAaN,UAAb,CAFG,CAAhB;AAIA,SAAOxB,QAAQ,CAAC2B,OAAD,EAAU,MAAMX,OAAO,CAACe,GAAR,CAAY,CAC1C1B,GAAG,CAACkB,SAAD,CADuC,EAE1ClB,GAAG,CAACmB,UAAD,CAFuC,CAAZ,CAAhB,CAAf;AAIA,CA5BD;;AA8BAf,MAAM,CAACC,OAAP,CAAeJ,KAAf,GAAuBA,KAAvB;AACAG,MAAM,CAACC,OAAP,CAAeF,MAAf,GAAwBA,MAAxB","sourcesContent":["'use strict';\nconst fs = require('fs');\nconst execa = require('execa');\nconst pFinally = require('p-finally');\nconst pify = require('pify');\nconst rimraf = require('rimraf');\nconst tempfile = require('tempfile');\n\nconst fsP = pify(fs);\nconst rmP = pify(rimraf);\nconst input = Symbol('inputPath');\nconst output = Symbol('outputPath');\n\nmodule.exports = opts => {\n\topts = Object.assign({}, opts);\n\n\tif (!Buffer.isBuffer(opts.input)) {\n\t\treturn Promise.reject(new Error('Input is required'));\n\t}\n\n\tif (typeof opts.bin !== 'string') {\n\t\treturn Promise.reject(new Error('Binary is required'));\n\t}\n\n\tif (!Array.isArray(opts.args)) {\n\t\treturn Promise.reject(new Error('Arguments are required'));\n\t}\n\n\tconst inputPath = opts.inputPath || tempfile();\n\tconst outputPath = opts.outputPath || tempfile();\n\n\topts.args = opts.args.map(x => x === input ? inputPath : x === output ? outputPath : x);\n\n\tconst promise = fsP.writeFile(inputPath, opts.input)\n\t\t.then(() => execa(opts.bin, opts.args))\n\t\t.then(() => fsP.readFile(outputPath));\n\n\treturn pFinally(promise, () => Promise.all([\n\t\trmP(inputPath),\n\t\trmP(outputPath)\n\t]));\n};\n\nmodule.exports.input = input;\nmodule.exports.output = output;\n"]},"metadata":{},"sourceType":"script"}