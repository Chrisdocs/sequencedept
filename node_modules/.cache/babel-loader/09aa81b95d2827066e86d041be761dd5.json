{"ast":null,"code":"'use strict';\n\nvar resolveCommand = require('./util/resolveCommand');\n\nvar hasEmptyArgumentBug = require('./util/hasEmptyArgumentBug');\n\nvar escapeArgument = require('./util/escapeArgument');\n\nvar escapeCommand = require('./util/escapeCommand');\n\nvar readShebang = require('./util/readShebang');\n\nvar isWin = process.platform === 'win32';\nvar skipShellRegExp = /\\.(?:com|exe)$/i; // Supported in Node >= 6 and >= 4.8\n\nvar supportsShellOption = parseInt(process.version.substr(1).split('.')[0], 10) >= 6 || parseInt(process.version.substr(1).split('.')[0], 10) === 4 && parseInt(process.version.substr(1).split('.')[1], 10) >= 8;\n\nfunction parseNonShell(parsed) {\n  var shebang;\n  var needsShell;\n  var applyQuotes;\n\n  if (!isWin) {\n    return parsed;\n  } // Detect & add support for shebangs\n\n\n  parsed.file = resolveCommand(parsed.command);\n  parsed.file = parsed.file || resolveCommand(parsed.command, true);\n  shebang = parsed.file && readShebang(parsed.file);\n\n  if (shebang) {\n    parsed.args.unshift(parsed.file);\n    parsed.command = shebang;\n    needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(resolveCommand(shebang) || resolveCommand(shebang, true));\n  } else {\n    needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(parsed.file);\n  } // If a shell is required, use cmd.exe and take care of escaping everything correctly\n\n\n  if (needsShell) {\n    // Escape command & arguments\n    applyQuotes = parsed.command !== 'echo'; // Do not quote arguments for the special \"echo\" command\n\n    parsed.command = escapeCommand(parsed.command);\n    parsed.args = parsed.args.map(function (arg) {\n      return escapeArgument(arg, applyQuotes);\n    }); // Make use of cmd.exe\n\n    parsed.args = ['/d', '/s', '/c', '\"' + parsed.command + (parsed.args.length ? ' ' + parsed.args.join(' ') : '') + '\"'];\n    parsed.command = process.env.comspec || 'cmd.exe';\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  }\n\n  return parsed;\n}\n\nfunction parseShell(parsed) {\n  var shellCommand; // If node supports the shell option, there's no need to mimic its behavior\n\n  if (supportsShellOption) {\n    return parsed;\n  } // Mimic node shell option, see: https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n\n\n  shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n  if (isWin) {\n    parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n    parsed.args = ['/d', '/s', '/c', '\"' + shellCommand + '\"'];\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  } else {\n    if (typeof parsed.options.shell === 'string') {\n      parsed.command = parsed.options.shell;\n    } else if (process.platform === 'android') {\n      parsed.command = '/system/bin/sh';\n    } else {\n      parsed.command = '/bin/sh';\n    }\n\n    parsed.args = ['-c', shellCommand];\n  }\n\n  return parsed;\n} // ------------------------------------------------\n\n\nfunction parse(command, args, options) {\n  var parsed; // Normalize arguments, similar to nodejs\n\n  if (args && !Array.isArray(args)) {\n    options = args;\n    args = null;\n  }\n\n  args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n\n  options = options || {}; // Build our parsed object\n\n  parsed = {\n    command: command,\n    args: args,\n    options: options,\n    file: undefined,\n    original: command\n  }; // Delegate further parsing to shell or non-shell\n\n  return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\n\nmodule.exports = parse;","map":{"version":3,"sources":["/Users/chriswolfe/Documents/webDev/Clients/SQ-DPT/my-app/node_modules/exec-buffer/node_modules/cross-spawn/lib/parse.js"],"names":["resolveCommand","require","hasEmptyArgumentBug","escapeArgument","escapeCommand","readShebang","isWin","process","platform","skipShellRegExp","supportsShellOption","parseInt","version","substr","split","parseNonShell","parsed","shebang","needsShell","applyQuotes","file","command","args","unshift","test","map","arg","length","join","env","comspec","options","windowsVerbatimArguments","parseShell","shellCommand","concat","shell","parse","Array","isArray","slice","undefined","original","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,cAAc,GAAGC,OAAO,CAAC,uBAAD,CAA5B;;AACA,IAAIC,mBAAmB,GAAGD,OAAO,CAAC,4BAAD,CAAjC;;AACA,IAAIE,cAAc,GAAGF,OAAO,CAAC,uBAAD,CAA5B;;AACA,IAAIG,aAAa,GAAGH,OAAO,CAAC,sBAAD,CAA3B;;AACA,IAAII,WAAW,GAAGJ,OAAO,CAAC,oBAAD,CAAzB;;AAEA,IAAIK,KAAK,GAAGC,OAAO,CAACC,QAAR,KAAqB,OAAjC;AACA,IAAIC,eAAe,GAAG,iBAAtB,C,CAEA;;AACA,IAAIC,mBAAmB,GAAGC,QAAQ,CAACJ,OAAO,CAACK,OAAR,CAAgBC,MAAhB,CAAuB,CAAvB,EAA0BC,KAA1B,CAAgC,GAAhC,EAAqC,CAArC,CAAD,EAA0C,EAA1C,CAAR,IAAyD,CAAzD,IACzBH,QAAQ,CAACJ,OAAO,CAACK,OAAR,CAAgBC,MAAhB,CAAuB,CAAvB,EAA0BC,KAA1B,CAAgC,GAAhC,EAAqC,CAArC,CAAD,EAA0C,EAA1C,CAAR,KAA0D,CAA1D,IAA+DH,QAAQ,CAACJ,OAAO,CAACK,OAAR,CAAgBC,MAAhB,CAAuB,CAAvB,EAA0BC,KAA1B,CAAgC,GAAhC,EAAqC,CAArC,CAAD,EAA0C,EAA1C,CAAR,IAAyD,CADzH;;AAGA,SAASC,aAAT,CAAuBC,MAAvB,EAA+B;AAC3B,MAAIC,OAAJ;AACA,MAAIC,UAAJ;AACA,MAAIC,WAAJ;;AAEA,MAAI,CAACb,KAAL,EAAY;AACR,WAAOU,MAAP;AACH,GAP0B,CAS3B;;;AACAA,EAAAA,MAAM,CAACI,IAAP,GAAcpB,cAAc,CAACgB,MAAM,CAACK,OAAR,CAA5B;AACAL,EAAAA,MAAM,CAACI,IAAP,GAAcJ,MAAM,CAACI,IAAP,IAAepB,cAAc,CAACgB,MAAM,CAACK,OAAR,EAAiB,IAAjB,CAA3C;AACAJ,EAAAA,OAAO,GAAGD,MAAM,CAACI,IAAP,IAAef,WAAW,CAACW,MAAM,CAACI,IAAR,CAApC;;AAEA,MAAIH,OAAJ,EAAa;AACTD,IAAAA,MAAM,CAACM,IAAP,CAAYC,OAAZ,CAAoBP,MAAM,CAACI,IAA3B;AACAJ,IAAAA,MAAM,CAACK,OAAP,GAAiBJ,OAAjB;AACAC,IAAAA,UAAU,GAAGhB,mBAAmB,IAAI,CAACO,eAAe,CAACe,IAAhB,CAAqBxB,cAAc,CAACiB,OAAD,CAAd,IAA2BjB,cAAc,CAACiB,OAAD,EAAU,IAAV,CAA9D,CAArC;AACH,GAJD,MAIO;AACHC,IAAAA,UAAU,GAAGhB,mBAAmB,IAAI,CAACO,eAAe,CAACe,IAAhB,CAAqBR,MAAM,CAACI,IAA5B,CAArC;AACH,GApB0B,CAsB3B;;;AACA,MAAIF,UAAJ,EAAgB;AACZ;AACAC,IAAAA,WAAW,GAAIH,MAAM,CAACK,OAAP,KAAmB,MAAlC,CAFY,CAEgC;;AAC5CL,IAAAA,MAAM,CAACK,OAAP,GAAiBjB,aAAa,CAACY,MAAM,CAACK,OAAR,CAA9B;AACAL,IAAAA,MAAM,CAACM,IAAP,GAAcN,MAAM,CAACM,IAAP,CAAYG,GAAZ,CAAgB,UAAUC,GAAV,EAAe;AACzC,aAAOvB,cAAc,CAACuB,GAAD,EAAMP,WAAN,CAArB;AACH,KAFa,CAAd,CAJY,CAQZ;;AACAH,IAAAA,MAAM,CAACM,IAAP,GAAc,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,MAAMN,MAAM,CAACK,OAAb,IAAwBL,MAAM,CAACM,IAAP,CAAYK,MAAZ,GAAqB,MAAMX,MAAM,CAACM,IAAP,CAAYM,IAAZ,CAAiB,GAAjB,CAA3B,GAAmD,EAA3E,IAAiF,GAApG,CAAd;AACAZ,IAAAA,MAAM,CAACK,OAAP,GAAiBd,OAAO,CAACsB,GAAR,CAAYC,OAAZ,IAAuB,SAAxC;AACAd,IAAAA,MAAM,CAACe,OAAP,CAAeC,wBAAf,GAA0C,IAA1C,CAXY,CAWqC;AACpD;;AAED,SAAOhB,MAAP;AACH;;AAED,SAASiB,UAAT,CAAoBjB,MAApB,EAA4B;AACxB,MAAIkB,YAAJ,CADwB,CAGxB;;AACA,MAAIxB,mBAAJ,EAAyB;AACrB,WAAOM,MAAP;AACH,GANuB,CAQxB;;;AACAkB,EAAAA,YAAY,GAAG,CAAClB,MAAM,CAACK,OAAR,EAAiBc,MAAjB,CAAwBnB,MAAM,CAACM,IAA/B,EAAqCM,IAArC,CAA0C,GAA1C,CAAf;;AAEA,MAAItB,KAAJ,EAAW;AACPU,IAAAA,MAAM,CAACK,OAAP,GAAiB,OAAOL,MAAM,CAACe,OAAP,CAAeK,KAAtB,KAAgC,QAAhC,GAA2CpB,MAAM,CAACe,OAAP,CAAeK,KAA1D,GAAkE7B,OAAO,CAACsB,GAAR,CAAYC,OAAZ,IAAuB,SAA1G;AACAd,IAAAA,MAAM,CAACM,IAAP,GAAc,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,MAAMY,YAAN,GAAqB,GAAxC,CAAd;AACAlB,IAAAA,MAAM,CAACe,OAAP,CAAeC,wBAAf,GAA0C,IAA1C,CAHO,CAG0C;AACpD,GAJD,MAIO;AACH,QAAI,OAAOhB,MAAM,CAACe,OAAP,CAAeK,KAAtB,KAAgC,QAApC,EAA8C;AAC1CpB,MAAAA,MAAM,CAACK,OAAP,GAAiBL,MAAM,CAACe,OAAP,CAAeK,KAAhC;AACH,KAFD,MAEO,IAAI7B,OAAO,CAACC,QAAR,KAAqB,SAAzB,EAAoC;AACvCQ,MAAAA,MAAM,CAACK,OAAP,GAAiB,gBAAjB;AACH,KAFM,MAEA;AACHL,MAAAA,MAAM,CAACK,OAAP,GAAiB,SAAjB;AACH;;AAEDL,IAAAA,MAAM,CAACM,IAAP,GAAc,CAAC,IAAD,EAAOY,YAAP,CAAd;AACH;;AAED,SAAOlB,MAAP;AACH,C,CAED;;;AAEA,SAASqB,KAAT,CAAehB,OAAf,EAAwBC,IAAxB,EAA8BS,OAA9B,EAAuC;AACnC,MAAIf,MAAJ,CADmC,CAGnC;;AACA,MAAIM,IAAI,IAAI,CAACgB,KAAK,CAACC,OAAN,CAAcjB,IAAd,CAAb,EAAkC;AAC9BS,IAAAA,OAAO,GAAGT,IAAV;AACAA,IAAAA,IAAI,GAAG,IAAP;AACH;;AAEDA,EAAAA,IAAI,GAAGA,IAAI,GAAGA,IAAI,CAACkB,KAAL,CAAW,CAAX,CAAH,GAAmB,EAA9B,CATmC,CASA;;AACnCT,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CAVmC,CAYnC;;AACAf,EAAAA,MAAM,GAAG;AACLK,IAAAA,OAAO,EAAEA,OADJ;AAELC,IAAAA,IAAI,EAAEA,IAFD;AAGLS,IAAAA,OAAO,EAAEA,OAHJ;AAILX,IAAAA,IAAI,EAAEqB,SAJD;AAKLC,IAAAA,QAAQ,EAAErB;AALL,GAAT,CAbmC,CAqBnC;;AACA,SAAOU,OAAO,CAACK,KAAR,GAAgBH,UAAU,CAACjB,MAAD,CAA1B,GAAqCD,aAAa,CAACC,MAAD,CAAzD;AACH;;AAED2B,MAAM,CAACC,OAAP,GAAiBP,KAAjB","sourcesContent":["'use strict';\n\nvar resolveCommand = require('./util/resolveCommand');\nvar hasEmptyArgumentBug = require('./util/hasEmptyArgumentBug');\nvar escapeArgument = require('./util/escapeArgument');\nvar escapeCommand = require('./util/escapeCommand');\nvar readShebang = require('./util/readShebang');\n\nvar isWin = process.platform === 'win32';\nvar skipShellRegExp = /\\.(?:com|exe)$/i;\n\n// Supported in Node >= 6 and >= 4.8\nvar supportsShellOption = parseInt(process.version.substr(1).split('.')[0], 10) >= 6 ||\n parseInt(process.version.substr(1).split('.')[0], 10) === 4 && parseInt(process.version.substr(1).split('.')[1], 10) >= 8;\n\nfunction parseNonShell(parsed) {\n    var shebang;\n    var needsShell;\n    var applyQuotes;\n\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    parsed.file = resolveCommand(parsed.command);\n    parsed.file = parsed.file || resolveCommand(parsed.command, true);\n    shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n        needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(resolveCommand(shebang) || resolveCommand(shebang, true));\n    } else {\n        needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(parsed.file);\n    }\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    if (needsShell) {\n        // Escape command & arguments\n        applyQuotes = (parsed.command !== 'echo');  // Do not quote arguments for the special \"echo\" command\n        parsed.command = escapeCommand(parsed.command);\n        parsed.args = parsed.args.map(function (arg) {\n            return escapeArgument(arg, applyQuotes);\n        });\n\n        // Make use of cmd.exe\n        parsed.args = ['/d', '/s', '/c', '\"' + parsed.command + (parsed.args.length ? ' ' + parsed.args.join(' ') : '') + '\"'];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true;  // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parseShell(parsed) {\n    var shellCommand;\n\n    // If node supports the shell option, there's no need to mimic its behavior\n    if (supportsShellOption) {\n        return parsed;\n    }\n\n    // Mimic node shell option, see: https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n    shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n    if (isWin) {\n        parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n        parsed.args = ['/d', '/s', '/c', '\"' + shellCommand + '\"'];\n        parsed.options.windowsVerbatimArguments = true;  // Tell node's spawn that the arguments are already escaped\n    } else {\n        if (typeof parsed.options.shell === 'string') {\n            parsed.command = parsed.options.shell;\n        } else if (process.platform === 'android') {\n            parsed.command = '/system/bin/sh';\n        } else {\n            parsed.command = '/bin/sh';\n        }\n\n        parsed.args = ['-c', shellCommand];\n    }\n\n    return parsed;\n}\n\n// ------------------------------------------------\n\nfunction parse(command, args, options) {\n    var parsed;\n\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : [];  // Clone array to avoid changing the original\n    options = options || {};\n\n    // Build our parsed object\n    parsed = {\n        command: command,\n        args: args,\n        options: options,\n        file: undefined,\n        original: command,\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n"]},"metadata":{},"sourceType":"script"}