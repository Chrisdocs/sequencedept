{"ast":null,"code":"import * as React from 'react';\nconst LEFT = \"Left\";\nconst RIGHT = \"Right\";\nconst UP = \"Up\";\nconst DOWN = \"Down\";\n/* global document */\n\nconst defaultProps = {\n  delta: 10,\n  preventScrollOnSwipe: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n  swipeDuration: Infinity,\n  touchEventOptions: {\n    passive: true\n  }\n};\nconst initialState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0]\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\n\nfunction getDirection(absX, absY, deltaX, deltaY) {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n\n  return UP;\n}\n\nfunction rotateXYByAngle(pos, angle) {\n  if (angle === 0) return pos;\n  const angleInRadians = Math.PI / 180 * angle;\n  const x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  const y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\n\nfunction getHandlers(set, handlerProps) {\n  const onStart = event => {\n    const isTouch = (\"touches\" in event); // if more than a single touch don't track, for now...\n\n    if (isTouch && event.touches.length > 1) return;\n    set((state, props) => {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse && !isTouch) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n\n      const {\n        clientX,\n        clientY\n      } = isTouch ? event.touches[0] : event;\n      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      props.onTouchStartOrOnMouseDown && props.onTouchStartOrOnMouseDown({\n        event\n      });\n      return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n        initial: xy.slice(),\n        xy,\n        start: event.timeStamp || 0\n      });\n    });\n  };\n\n  const onMove = event => {\n    set((state, props) => {\n      const isTouch = (\"touches\" in event); // Discount a swipe if additional touches are present after\n      // a swipe has started.\n\n      if (isTouch && event.touches.length > 1) {\n        return state;\n      } // if swipe has exceeded duration stop tracking\n\n\n      if (event.timeStamp - state.start > props.swipeDuration) {\n        return state.swiping ? Object.assign(Object.assign({}, state), {\n          swiping: false\n        }) : state;\n      }\n\n      const {\n        clientX,\n        clientY\n      } = isTouch ? event.touches[0] : event;\n      const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      const deltaX = x - state.xy[0];\n      const deltaY = y - state.xy[1];\n      const absX = Math.abs(deltaX);\n      const absY = Math.abs(deltaY);\n      const time = (event.timeStamp || 0) - state.start;\n      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      const vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n      const dir = getDirection(absX, absY, deltaX, deltaY); // if swipe is under delta and we have not started to track a swipe: skip update\n\n      const delta = typeof props.delta === \"number\" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps.delta;\n      if (absX < delta && absY < delta && !state.swiping) return state;\n      const eventData = {\n        absX,\n        absY,\n        deltaX,\n        deltaY,\n        dir,\n        event,\n        first: state.first,\n        initial: state.initial,\n        velocity,\n        vxvy\n      }; // call onSwipeStart if present and is first swipe event\n\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData); // call onSwiping if present\n\n      props.onSwiping && props.onSwiping(eventData); // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n\n      let cancelablePageSwipe = false;\n\n      if (props.onSwiping || props.onSwiped || props[`onSwiped${dir}`]) {\n        cancelablePageSwipe = true;\n      }\n\n      if (cancelablePageSwipe && props.preventScrollOnSwipe && props.trackTouch && event.cancelable) {\n        event.preventDefault();\n      }\n\n      return Object.assign(Object.assign({}, state), {\n        // first is now always false\n        first: false,\n        eventData,\n        swiping: true\n      });\n    });\n  };\n\n  const onEnd = event => {\n    set((state, props) => {\n      let eventData;\n\n      if (state.swiping && state.eventData) {\n        // if swipe is less than duration fire swiped callbacks\n        if (event.timeStamp - state.start < props.swipeDuration) {\n          eventData = Object.assign(Object.assign({}, state.eventData), {\n            event\n          });\n          props.onSwiped && props.onSwiped(eventData);\n          const onSwipedDir = props[`onSwiped${eventData.dir}`];\n          onSwipedDir && onSwipedDir(eventData);\n        }\n      } else {\n        props.onTap && props.onTap({\n          event\n        });\n      }\n\n      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({\n        event\n      });\n      return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n        eventData\n      });\n    });\n  };\n\n  const cleanUpMouse = () => {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n\n  const onUp = e => {\n    cleanUpMouse();\n    onEnd(e);\n  };\n  /**\n   * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n   * - true => { passive: false }\n   * - false => { passive: true } // Default\n   *\n   * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n   *\n   * props.touchEventOptions can also be set for all touch event listeners,\n   * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n   * supersede and force passive to false.\n   *\n   */\n\n\n  const attachTouch = (el, props) => {\n    let cleanup = () => {};\n\n    if (el && el.addEventListener) {\n      const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions); // attach touch event listeners and handlers\n\n      const tls = [[touchStart, onStart, baseOptions], // preventScrollOnSwipe option supersedes touchEventOptions.passive\n      [touchMove, onMove, Object.assign(Object.assign({}, baseOptions), props.preventScrollOnSwipe ? {\n        passive: false\n      } : {})], [touchEnd, onEnd, baseOptions]];\n      tls.forEach(([e, h, o]) => el.addEventListener(e, h, o)); // return properly scoped cleanup method for removing listeners, options not required\n\n      cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n    }\n\n    return cleanup;\n  };\n\n  const onRef = el => {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set((state, props) => {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n      const addState = {}; // if new DOM el clean up old DOM and reset cleanUpTouch\n\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = void 0;\n      } // only attach if we want to track touch\n\n\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(el, props);\n      } // store event attached DOM el for comparison, clean up, and re-attachment\n\n\n      return Object.assign(Object.assign(Object.assign({}, state), {\n        el\n      }), addState);\n    });\n  }; // set ref callback to attach touch event listeners\n\n\n  const output = {\n    ref: onRef\n  }; // if track mouse attach mouse down listener\n\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n\n  return [output, attachTouch];\n}\n\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n  // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n  if (!props.trackTouch || !state.el) {\n    if (state.cleanUpTouch) {\n      state.cleanUpTouch();\n    }\n\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: undefined\n    });\n  } // trackTouch is on, so if there are no handlers attached, attach them and exit\n\n\n  if (!state.cleanUpTouch) {\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: attachTouch(state.el, props)\n    });\n  } // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n  // remove and reattach handlers (this is required to update the passive option when attaching\n  // the handlers)\n\n\n  if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe || props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n    state.cleanUpTouch();\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: attachTouch(state.el, props)\n    });\n  }\n\n  return state;\n}\n\nfunction useSwipeable(options) {\n  const {\n    trackMouse\n  } = options;\n  const transientState = React.useRef(Object.assign({}, initialState));\n  const transientProps = React.useRef(Object.assign({}, defaultProps)); // track previous rendered props\n\n  const previousProps = React.useRef(Object.assign({}, transientProps.current));\n  previousProps.current = Object.assign({}, transientProps.current); // update current render props & defaults\n\n  transientProps.current = Object.assign(Object.assign({}, defaultProps), options); // Force defaults for config properties\n\n  let defaultKey;\n\n  for (defaultKey in defaultProps) {\n    if (transientProps.current[defaultKey] === void 0) {\n      transientProps.current[defaultKey] = defaultProps[defaultKey];\n    }\n  }\n\n  const [handlers, attachTouch] = React.useMemo(() => getHandlers(stateSetter => transientState.current = stateSetter(transientState.current, transientProps.current), {\n    trackMouse\n  }), [trackMouse]);\n  transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n  return handlers;\n}\n\nexport { DOWN, LEFT, RIGHT, UP, useSwipeable };","map":{"version":3,"sources":["../src/types.ts","../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\n\nconst LEFT = \"Left\";\nconst RIGHT = \"Right\";\nconst UP = \"Up\";\nconst DOWN = \"Down\";\n\n/* global document */\nconst defaultProps = {\n    delta: 10,\n    preventScrollOnSwipe: false,\n    rotationAngle: 0,\n    trackMouse: false,\n    trackTouch: true,\n    swipeDuration: Infinity,\n    touchEventOptions: { passive: true },\n};\nconst initialState = {\n    first: true,\n    initial: [0, 0],\n    start: 0,\n    swiping: false,\n    xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\nfunction getDirection(absX, absY, deltaX, deltaY) {\n    if (absX > absY) {\n        if (deltaX > 0) {\n            return RIGHT;\n        }\n        return LEFT;\n    }\n    else if (deltaY > 0) {\n        return DOWN;\n    }\n    return UP;\n}\nfunction rotateXYByAngle(pos, angle) {\n    if (angle === 0)\n        return pos;\n    const angleInRadians = (Math.PI / 180) * angle;\n    const x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n    const y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n    return [x, y];\n}\nfunction getHandlers(set, handlerProps) {\n    const onStart = (event) => {\n        const isTouch = \"touches\" in event;\n        // if more than a single touch don't track, for now...\n        if (isTouch && event.touches.length > 1)\n            return;\n        set((state, props) => {\n            // setup mouse listeners on document to track swipe since swipe can leave container\n            if (props.trackMouse && !isTouch) {\n                document.addEventListener(mouseMove, onMove);\n                document.addEventListener(mouseUp, onUp);\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            props.onTouchStartOrOnMouseDown &&\n                props.onTouchStartOrOnMouseDown({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { initial: xy.slice(), xy, start: event.timeStamp || 0 });\n        });\n    };\n    const onMove = (event) => {\n        set((state, props) => {\n            const isTouch = \"touches\" in event;\n            // Discount a swipe if additional touches are present after\n            // a swipe has started.\n            if (isTouch && event.touches.length > 1) {\n                return state;\n            }\n            // if swipe has exceeded duration stop tracking\n            if (event.timeStamp - state.start > props.swipeDuration) {\n                return state.swiping ? Object.assign(Object.assign({}, state), { swiping: false }) : state;\n            }\n            const { clientX, clientY } = isTouch ? event.touches[0] : event;\n            const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n            const deltaX = x - state.xy[0];\n            const deltaY = y - state.xy[1];\n            const absX = Math.abs(deltaX);\n            const absY = Math.abs(deltaY);\n            const time = (event.timeStamp || 0) - state.start;\n            const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n            const vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n            const dir = getDirection(absX, absY, deltaX, deltaY);\n            // if swipe is under delta and we have not started to track a swipe: skip update\n            const delta = typeof props.delta === \"number\"\n                ? props.delta\n                : props.delta[dir.toLowerCase()] ||\n                    defaultProps.delta;\n            if (absX < delta && absY < delta && !state.swiping)\n                return state;\n            const eventData = {\n                absX,\n                absY,\n                deltaX,\n                deltaY,\n                dir,\n                event,\n                first: state.first,\n                initial: state.initial,\n                velocity,\n                vxvy,\n            };\n            // call onSwipeStart if present and is first swipe event\n            eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n            // call onSwiping if present\n            props.onSwiping && props.onSwiping(eventData);\n            // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n            // so we can call preventDefault if needed\n            let cancelablePageSwipe = false;\n            if (props.onSwiping ||\n                props.onSwiped ||\n                props[`onSwiped${dir}`]) {\n                cancelablePageSwipe = true;\n            }\n            if (cancelablePageSwipe &&\n                props.preventScrollOnSwipe &&\n                props.trackTouch &&\n                event.cancelable) {\n                event.preventDefault();\n            }\n            return Object.assign(Object.assign({}, state), { \n                // first is now always false\n                first: false, eventData, swiping: true });\n        });\n    };\n    const onEnd = (event) => {\n        set((state, props) => {\n            let eventData;\n            if (state.swiping && state.eventData) {\n                // if swipe is less than duration fire swiped callbacks\n                if (event.timeStamp - state.start < props.swipeDuration) {\n                    eventData = Object.assign(Object.assign({}, state.eventData), { event });\n                    props.onSwiped && props.onSwiped(eventData);\n                    const onSwipedDir = props[`onSwiped${eventData.dir}`];\n                    onSwipedDir && onSwipedDir(eventData);\n                }\n            }\n            else {\n                props.onTap && props.onTap({ event });\n            }\n            props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\n            return Object.assign(Object.assign(Object.assign({}, state), initialState), { eventData });\n        });\n    };\n    const cleanUpMouse = () => {\n        // safe to just call removeEventListener\n        document.removeEventListener(mouseMove, onMove);\n        document.removeEventListener(mouseUp, onUp);\n    };\n    const onUp = (e) => {\n        cleanUpMouse();\n        onEnd(e);\n    };\n    /**\n     * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n     * - true => { passive: false }\n     * - false => { passive: true } // Default\n     *\n     * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n     *\n     * props.touchEventOptions can also be set for all touch event listeners,\n     * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n     * supersede and force passive to false.\n     *\n     */\n    const attachTouch = (el, props) => {\n        let cleanup = () => { };\n        if (el && el.addEventListener) {\n            const baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);\n            // attach touch event listeners and handlers\n            const tls = [\n                [touchStart, onStart, baseOptions],\n                // preventScrollOnSwipe option supersedes touchEventOptions.passive\n                [\n                    touchMove,\n                    onMove,\n                    Object.assign(Object.assign({}, baseOptions), (props.preventScrollOnSwipe ? { passive: false } : {})),\n                ],\n                [touchEnd, onEnd, baseOptions],\n            ];\n            tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\n            // return properly scoped cleanup method for removing listeners, options not required\n            cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n        }\n        return cleanup;\n    };\n    const onRef = (el) => {\n        // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n        // ignore null here\n        if (el === null)\n            return;\n        set((state, props) => {\n            // if the same DOM el as previous just return state\n            if (state.el === el)\n                return state;\n            const addState = {};\n            // if new DOM el clean up old DOM and reset cleanUpTouch\n            if (state.el && state.el !== el && state.cleanUpTouch) {\n                state.cleanUpTouch();\n                addState.cleanUpTouch = void 0;\n            }\n            // only attach if we want to track touch\n            if (props.trackTouch && el) {\n                addState.cleanUpTouch = attachTouch(el, props);\n            }\n            // store event attached DOM el for comparison, clean up, and re-attachment\n            return Object.assign(Object.assign(Object.assign({}, state), { el }), addState);\n        });\n    };\n    // set ref callback to attach touch event listeners\n    const output = {\n        ref: onRef,\n    };\n    // if track mouse attach mouse down listener\n    if (handlerProps.trackMouse) {\n        output.onMouseDown = onStart;\n    }\n    return [output, attachTouch];\n}\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n    // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n    if (!props.trackTouch || !state.el) {\n        if (state.cleanUpTouch) {\n            state.cleanUpTouch();\n        }\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: undefined });\n    }\n    // trackTouch is on, so if there are no handlers attached, attach them and exit\n    if (!state.cleanUpTouch) {\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n    // remove and reattach handlers (this is required to update the passive option when attaching\n    // the handlers)\n    if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\n        props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n        state.cleanUpTouch();\n        return Object.assign(Object.assign({}, state), { cleanUpTouch: attachTouch(state.el, props) });\n    }\n    return state;\n}\nfunction useSwipeable(options) {\n    const { trackMouse } = options;\n    const transientState = React.useRef(Object.assign({}, initialState));\n    const transientProps = React.useRef(Object.assign({}, defaultProps));\n    // track previous rendered props\n    const previousProps = React.useRef(Object.assign({}, transientProps.current));\n    previousProps.current = Object.assign({}, transientProps.current);\n    // update current render props & defaults\n    transientProps.current = Object.assign(Object.assign({}, defaultProps), options);\n    // Force defaults for config properties\n    let defaultKey;\n    for (defaultKey in defaultProps) {\n        if (transientProps.current[defaultKey] === void 0) {\n            transientProps.current[defaultKey] = defaultProps[defaultKey];\n        }\n    }\n    const [handlers, attachTouch] = React.useMemo(() => getHandlers((stateSetter) => (transientState.current = stateSetter(transientState.current, transientProps.current)), { trackMouse }), [trackMouse]);\n    transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n    return handlers;\n}\n\nexport { DOWN, LEFT, RIGHT, UP, useSwipeable };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}